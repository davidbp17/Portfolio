

import math
import numpy as np
from soundfile import SoundFile, _SoundFileInfo


class AudioFrames:
    """AudioFrames
    A class for iterating over frames of audio data
    """
    
    def __init__(self, filename, adv_ms, len_ms):
        """"AudioFrames(filename, adv_ms, len_ms)
        Create a stream of audio frames where each is in len_ms milliseconds long
        and frames are advanced by adv_ms.              
        """

        self.len_ms = len_ms
        self.adv_ms = adv_ms
        self.offset = 0     # offset start of frames to sample N (currently unused
        
        # Set up audio file
        self.filename = filename
        self.incomplete = False

        # Determine which interface to use
        self.init_soundfile()
        
        # Compute framing parameters in samples
        ms_per_s = 1000.0
        self.adv_N = int(self.Fs * (self.adv_ms / ms_per_s))
        self.len_N = int(self.Fs * (self.len_ms / ms_per_s))
        
        self.framedelta = np.timedelta64(adv_ms, 'ms')
        self.cumoffset = np.timedelta64(0, 's')
        
        # Compute parameters related to frame overlap and skip
        # number new samples each frame
        self.nonoverlap_N = min([self.len_N - self.adv_N, self.len_N])
        # number of samples from previous frame
        self.overlap_N = max([self.len_N - self.adv_N, 0])
        # number of samples needed to advance past the end of frame
        # to the beginning of the next
        self.next_frame_adv = max([0, self.adv_N - self.len_N])  
        
        self.current_sample = 0  # initial position
        
        self.repositioned = True  # Let iterator know that this will be first frame

    def init_soundfile(self):
        "init_soundfile() - initialize flexible SoundFile audio interface"

        self.soundfileinfo = _SoundFileInfo(self.filename, verbose=True)
        self.data = None
        self.fileobj = SoundFile(self.filename)

        self.Fs = self.fileobj.samplerate
        self.samplesN = self.soundfileinfo.frames
        self.channels = self.soundfileinfo.channels
        self.format = self.soundfileinfo.format
        self.subtype = self.soundfileinfo.subtype

    def get_framelen_samples(self):
        "get_framelen_ms - Return frame length in samples"
        return self.len_N
    
    def get_framelen_ms(self):
        "get_framelen_ms - Return frame length in ms"
        return self.len_ms
    
    def get_frameadv_samples(self):
        "get_frameadv_ms - Return frame advance in samples"
        return self.adv_N  

    def get_frameadv_ms(self):
        "get_frameadv_ms - Return frame advance in ms"
        return self.adv_ms

    def get_frameadv_s(self):
        "get_frameadv_s - Return frame advance in s"
        return self.adv_ms / 1000.0
    
    def get_Fs(self):
        "get_Fs() - Return sample rate"
        return self.Fs
    
    def __len__(self):
        "len() - number of frames"
        
        # Number of frames computation
        remainingN = self.samplesN - self.offset  # account for possible non-zero start
        #
        if self.incomplete:
            if self.interface == "SoundFileStream":
                # Returns all possible frames
                return math.ceil((remainingN-1)/ self.adv_N)
            else:
                return math.floor(remainingN / self.adv_N)
        else:
            # complete frames
            # length of frame - advance can be subtracted from sample count and divided by
            # advance
            return math.floor((remainingN - (self.len_N - self.adv_N)) / self.adv_N);

    def get_Nyquist(self):
        return self.Fs/2.0
    
    def get_params(self):
        "Return dict with file parameters"
        
        params = {
            "filename" : self.filename, 
            "Fs" : self.Fs,
            "samples" : self.samplesN,
            "framing" : {"adv_ms" : self.adv_ms, "len_ms" : self.len_ms, 
                         "adv_N":self.adv_N, "len_N" : self.len_N},
            "format" : self.format
            }
        if self.use_soundfile:
            params["subtype"] = self.subtype
            
        return params
    
    def shape(self):
        "shape() - shape of tensor generated by iterator"
        return np.asarray([self.len_N, 1])
    
    def size(self):
        "size() - number of elements in tensor generated by iterator"
        return np.asarray(np.product(self.shape()))
        
    def __iter__(self):
        """"iter() - Return a frame iterator
        WARNING:  Multiple iterators on same soundfile are not guaranteed to work as expected"""

        return soundfile_it(self)
    
    def seek_sample(self, N):
        "seek_sample(N) - Next iterator will start with sample N"

        if N > self.samplesN:
            raise ValueError("File %s seek to sample {}:  past end of file {}"%(
                self.filename, N, self.samplesN))
        else:
            # memory mapped, just set counter
            self.current_sample = N
    
    def get_data(self, startidx, N):
        """get_data(startidx, N) - Retrieve N samples starting at startidx.
        This has no side effects, the file position of iterators is unchanged
        """
        if startidx > len(self):
            raise ValueError("Read past end of data")
        
        stopidx = min(startidx+N, len(self))
        if self.channels > 1:
            data = self.data[startidx:stopidx,:]
        else:
            data = self.data[startidx:stopidx]
            
        return data
    
    def seek_frame(self, N):
        "seek_frame(N) - Next read will start at frame N"
        raise NotImplemented()


class soundfile_it(object):

    def __init__(self, frameobj):
        "soundfile_it(AudioFrames) - Create new iterator for specified instance"

        self.frameobj = frameobj
        self.sample_offset = frameobj.current_sample

        # Store underlying libraries frame iterator
        # We can iterate over this to generate one frame at a time
        self.framegen = frameobj.fileobj.blocks(
            blocksize=frameobj.len_N,
            overlap=frameobj.overlap_N)

    def __iter__(self):
        return self

    def next_time_s(self):
        "next_time_s() - Return start time of next frame that will be generated"
        offset_s = self.sample_offset / self.frameobj.Fs
        return offset_s

    def __next__(self):
        "next() - Return next frame"

        frames = next(self.framegen)
        if frames.shape[0] != self.frameobj.len_N and not self.frameobj.incomplete:
            # User did not want incomplete frames
            raise StopIteration

        self.sample_offset = self.sample_offset + self.frameobj.adv_N

        return frames
            
            
            
        
    
        
        
        